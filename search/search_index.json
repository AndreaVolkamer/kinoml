{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KinoML \u00b6 Structure-informed machine learning for kinase modeling Warning This is module is undergoing heavy development. None of the API calls are final. This software is provided without any guarantees of correctness, you will likely encounter bugs. If you are interested in this code, please wait for the official release to use it. In the mean time, to stay informed of development progress you are encouraged to: Subscribe for new releases (use Watch> Releases only on GitHub) Check out the Github repository . What is KinoML? \u00b6 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis facilisis consequat arcu eu tristique. Sed ut diam accumsan, iaculis leo vitae, laoreet arcu. Vivamus vel aliquam risus. Aenean magna massa, dictum ac lobortis in, porttitor at tortor. Curabitur et massa nec elit placerat fermentum. Morbi bibendum mi in felis eleifend mattis. Nullam sagittis augue at sagittis egestas. Curabitur suscipit id dolor eget feugiat. Etiam enim nunc, lobortis vitae porttitor non, suscipit eget metus. Aliquam tempor ipsum mauris, et eleifend turpis tincidunt pharetra. Mauris ex turpis, consequat sed tellus ut, dictum fringilla nunc. Donec vitae placerat orci, sed tempus elit.","title":"Home"},{"location":"#kinoml","text":"Structure-informed machine learning for kinase modeling Warning This is module is undergoing heavy development. None of the API calls are final. This software is provided without any guarantees of correctness, you will likely encounter bugs. If you are interested in this code, please wait for the official release to use it. In the mean time, to stay informed of development progress you are encouraged to: Subscribe for new releases (use Watch> Releases only on GitHub) Check out the Github repository .","title":"KinoML"},{"location":"#what-is-kinoml","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis facilisis consequat arcu eu tristique. Sed ut diam accumsan, iaculis leo vitae, laoreet arcu. Vivamus vel aliquam risus. Aenean magna massa, dictum ac lobortis in, porttitor at tortor. Curabitur et massa nec elit placerat fermentum. Morbi bibendum mi in felis eleifend mattis. Nullam sagittis augue at sagittis egestas. Curabitur suscipit id dolor eget feugiat. Etiam enim nunc, lobortis vitae porttitor non, suscipit eget metus. Aliquam tempor ipsum mauris, et eleifend turpis tincidunt pharetra. Mauris ex turpis, consequat sed tellus ut, dictum fringilla nunc. Donec vitae placerat orci, sed tempus elit.","title":"What is KinoML?"},{"location":"getting_started/","text":"Getting started \u00b6 This page details how to get started with KinoML.","title":"Getting started"},{"location":"getting_started/#getting-started","text":"This page details how to get started with KinoML.","title":"Getting started"},{"location":"install/","text":"Installation \u00b6 Use conda .","title":"Installation"},{"location":"install/#installation","text":"Use conda .","title":"Installation"},{"location":"api/__init__/","text":"KinoML is a structure-informed machine learning library with a focus on kinase modeling","title":"kinoml"},{"location":"api/utils/","text":"defaultdictwithargs \u00b6 A defaultdict that will create new values based on the missing value Parameters Name Type Description Default call Callable Factory to be called on missing key required datapath ( path ) \u00b6 Show source code in kinoml/utils.py 23 24 25 26 27 28 29 30 31 32 def datapath ( path : str ) -> Path : \"\"\" Return absolute path to a file contained in this package's `data`. Parameters: path: Relative path to file in `data`. Returns: Absolute path \"\"\" return PACKAGE_ROOT / \"data\" / path Return absolute path to a file contained in this package's data . Parameters Name Type Description Default path str Relative path to file in data . required Returns Type Description Path Absolute path grouper ( iterable , n , fillvalue = None ) \u00b6 Show source code in kinoml/utils.py 35 36 37 38 39 40 41 42 43 44 45 46 47 def grouper ( iterable : Iterable , n : int , fillvalue : Any = None ) -> Iterable : \"\"\" Given an iterable, consume it in n-sized groups, filling it with fillvalue if needed. Parameters: iterable: list, tuple, str or anything that can be grouped n: size of the group fillvalue: last group will be padded with this object until `len(group)==n` \"\"\" args = [ iter ( iterable )] * n return zip_longest ( * args , fillvalue = fillvalue ) Given an iterable, consume it in n-sized groups, filling it with fillvalue if needed. Parameters Name Type Description Default iterable Iterable list, tuple, str or anything that can be grouped required n int size of the group required fillvalue Any last group will be padded with this object until len(group)==n None","title":"utils"},{"location":"api/utils/#kinoml.utils.defaultdictwithargs","text":"A defaultdict that will create new values based on the missing value Parameters Name Type Description Default call Callable Factory to be called on missing key required","title":"defaultdictwithargs"},{"location":"api/utils/#kinoml.utils.datapath","text":"Show source code in kinoml/utils.py 23 24 25 26 27 28 29 30 31 32 def datapath ( path : str ) -> Path : \"\"\" Return absolute path to a file contained in this package's `data`. Parameters: path: Relative path to file in `data`. Returns: Absolute path \"\"\" return PACKAGE_ROOT / \"data\" / path Return absolute path to a file contained in this package's data . Parameters Name Type Description Default path str Relative path to file in data . required Returns Type Description Path Absolute path","title":"datapath()"},{"location":"api/utils/#kinoml.utils.grouper","text":"Show source code in kinoml/utils.py 35 36 37 38 39 40 41 42 43 44 45 46 47 def grouper ( iterable : Iterable , n : int , fillvalue : Any = None ) -> Iterable : \"\"\" Given an iterable, consume it in n-sized groups, filling it with fillvalue if needed. Parameters: iterable: list, tuple, str or anything that can be grouped n: size of the group fillvalue: last group will be padded with this object until `len(group)==n` \"\"\" args = [ iter ( iterable )] * n return zip_longest ( * args , fillvalue = fillvalue ) Given an iterable, consume it in n-sized groups, filling it with fillvalue if needed. Parameters Name Type Description Default iterable Iterable list, tuple, str or anything that can be grouped required n int size of the group required fillvalue Any last group will be padded with this object until len(group)==n None","title":"grouper()"},{"location":"api/analysis/__init__/","text":"","title":"analysis"},{"location":"api/core/__init__/","text":"::: kinoml.core. init","title":"  init  "},{"location":"api/core/components/","text":"MolecularComponent \u00b6 Abstract base molecular entity. Several components can form a System. Proteins, ligands, and other molecular entities are derived from this class.","title":"components"},{"location":"api/core/components/#kinoml.core.components.MolecularComponent","text":"Abstract base molecular entity. Several components can form a System. Proteins, ligands, and other molecular entities are derived from this class.","title":"MolecularComponent"},{"location":"api/core/conditions/","text":"AssayConditions \u00b6 Contains information about the experimental conditions of a given assay. Parameters Name Type Description Default pH Union[int, float] Acidity conditions 7.0 sanity_checks ( self ) \u00b6 Show source code in core/conditions.py 73 74 75 def sanity_checks ( self ): super () . sanity_checks () assert 0 <= self . pH <= 14 , f \"pH must be within [0, 14], but { self . pH } was specified\" Perform some checks for valid values BaseConditions \u00b6 Contains information about the experimental conditions. We ensure objects are immutable by using read-only properties for all attributes. Do NOT modify private attributes or hashing will break. Parameters Name Type Description Default strict bool Whether to perform sanity checks at initialization. True sanity_checks ( self ) \u00b6 Show source code in core/conditions.py 22 23 24 25 def sanity_checks ( self ): \"\"\" Perform some checks for valid values \"\"\" Perform some checks for valid values","title":"conditions"},{"location":"api/core/conditions/#kinoml.core.conditions.AssayConditions","text":"Contains information about the experimental conditions of a given assay. Parameters Name Type Description Default pH Union[int, float] Acidity conditions 7.0","title":"AssayConditions"},{"location":"api/core/conditions/#kinoml.core.conditions.AssayConditions.sanity_checks","text":"Show source code in core/conditions.py 73 74 75 def sanity_checks ( self ): super () . sanity_checks () assert 0 <= self . pH <= 14 , f \"pH must be within [0, 14], but { self . pH } was specified\" Perform some checks for valid values","title":"sanity_checks()"},{"location":"api/core/conditions/#kinoml.core.conditions.BaseConditions","text":"Contains information about the experimental conditions. We ensure objects are immutable by using read-only properties for all attributes. Do NOT modify private attributes or hashing will break. Parameters Name Type Description Default strict bool Whether to perform sanity checks at initialization. True","title":"BaseConditions"},{"location":"api/core/conditions/#kinoml.core.conditions.BaseConditions.sanity_checks","text":"Show source code in core/conditions.py 22 23 24 25 def sanity_checks ( self ): \"\"\" Perform some checks for valid values \"\"\" Perform some checks for valid values","title":"sanity_checks()"},{"location":"api/core/ligands/","text":"Ligand \u00b6 Small molecule object based on the OpenForceField toolkit. Todo Everything in this class __init__ ( self , _provenance = None , name = '' , * args , ** kwargs ) \u00b6 Show source code in core/ligands.py 19 20 21 def __init__ ( self , _provenance = None , name = \"\" , * args , ** kwargs ): BaseLigand . __init__ ( self , name = name , _provenance = _provenance ) Molecule . __init__ ( self , * args , ** kwargs ) Create a new Molecule object Parameters \u00b6 other : optional, default=None If specified, attempt to construct a copy of the Molecule from the specified object. This can be any one of the following: * a :class:`Molecule` object * a file that can be used to construct a :class:`Molecule` object * an ``openeye.oechem.OEMol`` * an ``rdkit.Chem.rdchem.Mol`` * a serialized :class:`Molecule` object Examples \u00b6 Create an empty molecule: empty_molecule = Molecule() Create a molecule from a file that can be used to construct a molecule, using either a filename or file-like object: from openforcefield.utils import get_data_file_path sdf_filepath = get_data_file_path('molecules/ethanol.sdf') molecule = Molecule(sdf_filepath) molecule = Molecule(open(sdf_filepath, 'r'), file_format='sdf') import gzip mol2_gz_filepath = get_data_file_path('molecules/toluene.mol2.gz') molecule = Molecule(gzip.GzipFile(mol2_gz_filepath, 'r'), file_format='mol2') Create a molecule from another molecule: molecule_copy = Molecule(molecule) Convert to OpenEye OEMol object oemol = molecule.to_openeye() Create a molecule from an OpenEye molecule: molecule = Molecule(oemol) Convert to RDKit Mol object rdmol = molecule.to_rdkit() Create a molecule from an RDKit molecule: molecule = Molecule(rdmol) Create a molecule from a serialized molecule object: serialized_molecule = molecule. getstate () molecule_copy = Molecule(serialized_molecule) .. todo :: If a filename or file-like object is specified but the file contains more than one molecule, what is the proper behavior? Read just the first molecule, or raise an exception if more than one molecule is found? Should we also support SMILES strings or IUPAC names for other ? from_smiles ( smiles , name = '' , ** kwargs ) (classmethod) \u00b6 Show source code in core/ligands.py 25 26 27 28 29 30 31 32 33 34 @classmethod def from_smiles ( cls , smiles , name = \"\" , ** kwargs ): # pylint: disable=arguments-differ \"\"\" Same as `openforcefield.topology.Molecule`, but adding information about the original SMILES to `._provenance` dict. \"\"\" ligand = super () . from_smiles ( smiles , ** kwargs ) if not name : name = smiles return cls ( other = ligand , name = name , _provenance = { \"smiles\" : smiles }) Same as openforcefield.topology.Molecule , but adding information about the original SMILES to ._provenance dict.","title":"ligands"},{"location":"api/core/ligands/#kinoml.core.ligands.Ligand","text":"Small molecule object based on the OpenForceField toolkit. Todo Everything in this class","title":"Ligand"},{"location":"api/core/ligands/#kinoml.core.ligands.Ligand.__init__","text":"Show source code in core/ligands.py 19 20 21 def __init__ ( self , _provenance = None , name = \"\" , * args , ** kwargs ): BaseLigand . __init__ ( self , name = name , _provenance = _provenance ) Molecule . __init__ ( self , * args , ** kwargs ) Create a new Molecule object","title":"__init__()"},{"location":"api/core/ligands/#parameters","text":"other : optional, default=None If specified, attempt to construct a copy of the Molecule from the specified object. This can be any one of the following: * a :class:`Molecule` object * a file that can be used to construct a :class:`Molecule` object * an ``openeye.oechem.OEMol`` * an ``rdkit.Chem.rdchem.Mol`` * a serialized :class:`Molecule` object","title":"Parameters"},{"location":"api/core/ligands/#examples","text":"Create an empty molecule: empty_molecule = Molecule() Create a molecule from a file that can be used to construct a molecule, using either a filename or file-like object: from openforcefield.utils import get_data_file_path sdf_filepath = get_data_file_path('molecules/ethanol.sdf') molecule = Molecule(sdf_filepath) molecule = Molecule(open(sdf_filepath, 'r'), file_format='sdf') import gzip mol2_gz_filepath = get_data_file_path('molecules/toluene.mol2.gz') molecule = Molecule(gzip.GzipFile(mol2_gz_filepath, 'r'), file_format='mol2') Create a molecule from another molecule: molecule_copy = Molecule(molecule) Convert to OpenEye OEMol object oemol = molecule.to_openeye() Create a molecule from an OpenEye molecule: molecule = Molecule(oemol) Convert to RDKit Mol object rdmol = molecule.to_rdkit() Create a molecule from an RDKit molecule: molecule = Molecule(rdmol) Create a molecule from a serialized molecule object: serialized_molecule = molecule. getstate () molecule_copy = Molecule(serialized_molecule) .. todo :: If a filename or file-like object is specified but the file contains more than one molecule, what is the proper behavior? Read just the first molecule, or raise an exception if more than one molecule is found? Should we also support SMILES strings or IUPAC names for other ?","title":"Examples"},{"location":"api/core/ligands/#kinoml.core.ligands.Ligand.from_smiles","text":"Show source code in core/ligands.py 25 26 27 28 29 30 31 32 33 34 @classmethod def from_smiles ( cls , smiles , name = \"\" , ** kwargs ): # pylint: disable=arguments-differ \"\"\" Same as `openforcefield.topology.Molecule`, but adding information about the original SMILES to `._provenance` dict. \"\"\" ligand = super () . from_smiles ( smiles , ** kwargs ) if not name : name = smiles return cls ( other = ligand , name = name , _provenance = { \"smiles\" : smiles }) Same as openforcefield.topology.Molecule , but adding information about the original SMILES to ._provenance dict.","title":"from_smiles()"},{"location":"api/core/measurements/","text":"BaseMeasurement \u00b6 We will have several subclasses depending on the experiment. They will also provide loss functions tailored to it. Values of the measurement can have more than one replicate. In fact, single replicates are considered a specific case of a multi-replicate. Parameters Name Type Description Default values Union[float, Iterable[float]] The numeric measurement(s) required conditions AssayConditions Experimental conditions of this measurement required components Iterable[kinoml.core.components.MolecularComponent] Molecular entities measured required strict bool Whether to perform sanity checks at initialization. True Todo Investigate possible uses for pint sanity_checks ( self ) \u00b6 Show source code in core/measurements.py 47 48 49 50 def sanity_checks ( self ): \"\"\" Perform some checks for valid values \"\"\" Perform some checks for valid values PercentageDisplacementMeasurement \u00b6 Measurement where the value(s) must be percentage(s) of displacement. sanity_checks ( self ) \u00b6 Show source code in core/measurements.py 69 70 71 def sanity_checks ( self ): super () . sanity_checks () assert ( 0 <= self . values <= 100 ) . all (), f \"One or more values are not in [0, 100]\" Perform some checks for valid values to_IC50 ( self ) \u00b6 Show source code in core/measurements.py 73 74 75 76 77 def to_IC50 ( self ): \"\"\" Ideally, `self.conditions` should contain all we need to do the math here? \"\"\" Ideally, self.conditions should contain all we need to do the math here?","title":"measurements"},{"location":"api/core/measurements/#kinoml.core.measurements.BaseMeasurement","text":"We will have several subclasses depending on the experiment. They will also provide loss functions tailored to it. Values of the measurement can have more than one replicate. In fact, single replicates are considered a specific case of a multi-replicate. Parameters Name Type Description Default values Union[float, Iterable[float]] The numeric measurement(s) required conditions AssayConditions Experimental conditions of this measurement required components Iterable[kinoml.core.components.MolecularComponent] Molecular entities measured required strict bool Whether to perform sanity checks at initialization. True Todo Investigate possible uses for pint","title":"BaseMeasurement"},{"location":"api/core/measurements/#kinoml.core.measurements.BaseMeasurement.sanity_checks","text":"Show source code in core/measurements.py 47 48 49 50 def sanity_checks ( self ): \"\"\" Perform some checks for valid values \"\"\" Perform some checks for valid values","title":"sanity_checks()"},{"location":"api/core/measurements/#kinoml.core.measurements.PercentageDisplacementMeasurement","text":"Measurement where the value(s) must be percentage(s) of displacement.","title":"PercentageDisplacementMeasurement"},{"location":"api/core/measurements/#kinoml.core.measurements.PercentageDisplacementMeasurement.sanity_checks","text":"Show source code in core/measurements.py 69 70 71 def sanity_checks ( self ): super () . sanity_checks () assert ( 0 <= self . values <= 100 ) . all (), f \"One or more values are not in [0, 100]\" Perform some checks for valid values","title":"sanity_checks()"},{"location":"api/core/measurements/#kinoml.core.measurements.PercentageDisplacementMeasurement.to_IC50","text":"Show source code in core/measurements.py 73 74 75 76 77 def to_IC50 ( self ): \"\"\" Ideally, `self.conditions` should contain all we need to do the math here? \"\"\" Ideally, self.conditions should contain all we need to do the math here?","title":"to_IC50()"},{"location":"api/core/proteins/","text":"AminoAcidSequence \u00b6 Biosequence that only allows proteinic aminoacids Kinase \u00b6 Extends Protein to provide kinase-specific methods of instantiation. ProteinStructure \u00b6 Structural representation of a protein Todo This is probably going to be redone, so do not invest too much","title":"proteins"},{"location":"api/core/proteins/#kinoml.core.proteins.AminoAcidSequence","text":"Biosequence that only allows proteinic aminoacids","title":"AminoAcidSequence"},{"location":"api/core/proteins/#kinoml.core.proteins.Kinase","text":"Extends Protein to provide kinase-specific methods of instantiation.","title":"Kinase"},{"location":"api/core/proteins/#kinoml.core.proteins.ProteinStructure","text":"Structural representation of a protein Todo This is probably going to be redone, so do not invest too much","title":"ProteinStructure"},{"location":"api/core/sequences/","text":"Biosequence \u00b6 Base class for string representations of biological polymers (nucleic acids, peptides, proteins...) Todo How to handle several mutations at the same time, while keeping indices relevant (after a deletion, a replacement or insertion position might be wrong). __new__ ( cls , value , name = '' , _provenance = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in core/sequences.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __new__ ( cls , value , name = \"\" , _provenance = None , * args , ** kwargs ): \"\"\" We are subclassing `str` to: - provide a `._provenance` dict - validate input is part of the allowed alphabet \"\"\" diff = set ( value ) . difference ( cls . ALPHABET ) if diff : raise ValueError ( f \"Biosequence can only contain characters in { cls . ALPHABET } , \" f \"but found these extra ones: { diff } .\" ) s = super () . __new__ ( cls , value , * args , ** kwargs ) s . name = name s . _provenance = {} # TODO: We might override some provenance data with this blind update if _provenance is not None : s . _provenance . update ( _provenance ) return s We are subclassing str to: provide a ._provenance dict validate input is part of the allowed alphabet cut ( self , start , stop , check = True ) \u00b6 Show source code in core/sequences.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def cut ( self , start : str , stop : str , check : bool = True ) -> \"Biosequence\" : \"\"\" Slice a sequence using biological notation Parameters: start: Starting element and 1-indexed position; e.g. C123 stop: Ending element and 1-indexed position; e.g. T234 This will be included in the resulting sequence check: Whether to test if the existing elements correspond to those specified in the bounds Returns: Substring corresponding to [start, end]. Right bound is included! __Examples__ ```python >>> s = Biosequence(\"ATCGTHCTCH\") >>> s.cut(\"T2\", \"T8\") \"TCGTHCT\" ``` \"\"\" start_res , start_pos = start [ 0 ], int ( start [ 1 :]) stop_res , stop_pos = stop [ 0 ], int ( stop [ 1 :]) if check : assert ( start_res == self [ start_pos - 1 ] ), f \"Element at position { start_pos } is not { start_res } \" assert ( stop_res == self [ stop_pos - 1 ] ), f \"Element at position { stop_pos } is not { stop_res } \" return self . __class__ ( self [ start_pos - 1 : stop_pos ], name = f \" { self . name }{ ' | ' if self . name else '' } Cut: { start } / { stop } \" , _provenance = { \"cut\" : ( start , stop )}, ) Slice a sequence using biological notation Parameters Name Type Description Default start str Starting element and 1-indexed position; e.g. C123 required stop str Ending element and 1-indexed position; e.g. T234 This will be included in the resulting sequence required check bool Whether to test if the existing elements correspond to those specified in the bounds True Returns Type Description Biosequence Substring corresponding to [start, end]. Right bound is included! Examples >>> s = Biosequence ( \"ATCGTHCTCH\" ) >>> s . cut ( \"T2\" , \"T8\" ) \"TCGTHCT\" from_ncbi ( * accessions ) (classmethod) \u00b6 Show source code in core/sequences.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @classmethod def from_ncbi ( cls , * accessions : str ,) -> Union [ \"Biosequence\" , Iterable [ \"Biosequence\" ]]: \"\"\" Get FASTA sequence from an online NCBI identifier Parameters: accessions: NCBI identifier. Multiple can be provided! Returns: Retrieved biosequence(s) __Examples__ ```python >>> sequence = AminoAcidSequence.from_ncbi(\"AAC05299.1\") >>> print(sequence[:10]) MSVNSEKSSS >>> print(sequence.name) AAC05299.1 serine kinase SRPK2 [Homo sapiens] ``` \"\"\" if cls . _ACCESSION_URL is None : raise NotImplementedError if len ( accessions ) > cls . ACCESSION_MAX_RETRIEVAL : raise ValueError ( f \"You can only provide { cls . ACCESSION_MAX_RETRIEVAL } accessions at the same time.\" ) r = requests . get ( cls . _ACCESSION_URL . format ( \",\" . join ( accessions ))) r . raise_for_status () sequences = [] for line in r . text . splitlines (): line = line . strip () if not line : continue if line . startswith ( \">\" ): sequences . append ({ \"name\" : line [ 1 :], \"sequence\" : []}) else : sequences [ - 1 ][ \"sequence\" ] . append ( line ) if not sequences : return objects = [] for sequence , accession in zip ( sequences , accessions ): obj = cls ( \"\" . join ( sequence [ \"sequence\" ]), name = sequence [ \"name\" ], _provenance = { \"accession\" : accession }, ) objects . append ( obj ) if not objects : return None if len ( objects ) == 1 : return objects [ 0 ] return objects Get FASTA sequence from an online NCBI identifier Parameters Name Type Description Default *accessions str NCBI identifier. Multiple can be provided! () Returns Type Description Union[ForwardRef('Biosequence'), Iterable[ForwardRef('Biosequence')]] Retrieved biosequence(s) Examples >>> sequence = AminoAcidSequence . from_ncbi ( \"AAC05299.1\" ) >>> print ( sequence [: 10 ]) MSVNSEKSSS >>> print ( sequence . name ) AAC05299 . 1 serine kinase SRPK2 [ Homo sapiens ] mutate ( self , * mutations , raise_errors = True ) \u00b6 Show source code in core/sequences.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def mutate ( self , * mutations : str , raise_errors : bool = True ) -> \"Biosequence\" : \"\"\" Apply a mutation on the sequence using biological notation. Parameters: mutations: Mutations to be applied. Indices are always 1-indexed. It can be one of: (1) substitution, like `C234T` (C at position 234 will be replaced by T); (2) deletion, like `L746-A750del` (delete everything between L at position 746 A at position 750, bounds not included); (3) insertion, like `1151Tins` (insert a T after position 1151) raise_errors: Raise ValueError if one of the mutations is not supported. Returns: The edited sequence Examples: ```python >>> s = Biosequence(\"ATCGTHCTCH\") >>> s.mutate(\"C3P\") \"ATPGTHCTCH\" >>> s.mutate(\"T2-T5del\") \"ATTHCTCH\" >>> s.mutate(\"5Tins\") \"ATCGTTHCTCH\" ``` \"\"\" # We can only handle one insertion or deletion at once now mutation_types = { m : self . _type_mutation ( m , raise_errors ) for m in mutations } mutation_count = Counter ( mutation_types . values ()) if mutation_count [ \"insertion\" ] + mutation_count [ \"deletion\" ] > 1 : msg = f \"Only one simultaneous insertion or deletion is currently supported. You provided ` { ',' . join ( mutations ) } `\" if raise_errors : raise ValueError ( msg ) logger . warning ( \"Warning: %s \" , msg ) return None # Reverse alphabetical order (substitutions will come first) mutated = self for mutation in sorted ( mutations , key = lambda m : mutation_count [ m ], reverse = True ): if None in ( mutation , mutation_types [ mutation ]): continue operation = getattr ( mutated , f \"_mutate_with_ { mutation_types [ mutation ] } \" ) mutated = operation ( mutation ) mutated . name += f \" (mutations: { ', ' . join ( mutations ) } )\" mutated . _provenance . update ({ \"mutations\" : mutations }) return mutated Apply a mutation on the sequence using biological notation. Parameters Name Type Description Default *mutations str Mutations to be applied. Indices are always 1-indexed. It can be one of: (1) substitution, like C234T (C at position 234 will be replaced by T); (2) deletion, like L746-A750del (delete everything between L at position 746 A at position 750, bounds not included); (3) insertion, like 1151Tins (insert a T after position 1151) () raise_errors bool Raise ValueError if one of the mutations is not supported. True Returns Type Description Biosequence The edited sequence Examples: >>> s = Biosequence ( \"ATCGTHCTCH\" ) >>> s . mutate ( \"C3P\" ) \"ATPGTHCTCH\" >>> s . mutate ( \"T2-T5del\" ) \"ATTHCTCH\" >>> s . mutate ( \"5Tins\" ) \"ATCGTTHCTCH\" DNASequence \u00b6 Biosequence that only allows DNA bases RNASequence \u00b6 Biosequence that only allows RNA bases","title":"sequences"},{"location":"api/core/sequences/#kinoml.core.sequences.Biosequence","text":"Base class for string representations of biological polymers (nucleic acids, peptides, proteins...) Todo How to handle several mutations at the same time, while keeping indices relevant (after a deletion, a replacement or insertion position might be wrong).","title":"Biosequence"},{"location":"api/core/sequences/#kinoml.core.sequences.Biosequence.__new__","text":"Show source code in core/sequences.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __new__ ( cls , value , name = \"\" , _provenance = None , * args , ** kwargs ): \"\"\" We are subclassing `str` to: - provide a `._provenance` dict - validate input is part of the allowed alphabet \"\"\" diff = set ( value ) . difference ( cls . ALPHABET ) if diff : raise ValueError ( f \"Biosequence can only contain characters in { cls . ALPHABET } , \" f \"but found these extra ones: { diff } .\" ) s = super () . __new__ ( cls , value , * args , ** kwargs ) s . name = name s . _provenance = {} # TODO: We might override some provenance data with this blind update if _provenance is not None : s . _provenance . update ( _provenance ) return s We are subclassing str to: provide a ._provenance dict validate input is part of the allowed alphabet","title":"__new__()"},{"location":"api/core/sequences/#kinoml.core.sequences.Biosequence.cut","text":"Show source code in core/sequences.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def cut ( self , start : str , stop : str , check : bool = True ) -> \"Biosequence\" : \"\"\" Slice a sequence using biological notation Parameters: start: Starting element and 1-indexed position; e.g. C123 stop: Ending element and 1-indexed position; e.g. T234 This will be included in the resulting sequence check: Whether to test if the existing elements correspond to those specified in the bounds Returns: Substring corresponding to [start, end]. Right bound is included! __Examples__ ```python >>> s = Biosequence(\"ATCGTHCTCH\") >>> s.cut(\"T2\", \"T8\") \"TCGTHCT\" ``` \"\"\" start_res , start_pos = start [ 0 ], int ( start [ 1 :]) stop_res , stop_pos = stop [ 0 ], int ( stop [ 1 :]) if check : assert ( start_res == self [ start_pos - 1 ] ), f \"Element at position { start_pos } is not { start_res } \" assert ( stop_res == self [ stop_pos - 1 ] ), f \"Element at position { stop_pos } is not { stop_res } \" return self . __class__ ( self [ start_pos - 1 : stop_pos ], name = f \" { self . name }{ ' | ' if self . name else '' } Cut: { start } / { stop } \" , _provenance = { \"cut\" : ( start , stop )}, ) Slice a sequence using biological notation Parameters Name Type Description Default start str Starting element and 1-indexed position; e.g. C123 required stop str Ending element and 1-indexed position; e.g. T234 This will be included in the resulting sequence required check bool Whether to test if the existing elements correspond to those specified in the bounds True Returns Type Description Biosequence Substring corresponding to [start, end]. Right bound is included! Examples >>> s = Biosequence ( \"ATCGTHCTCH\" ) >>> s . cut ( \"T2\" , \"T8\" ) \"TCGTHCT\"","title":"cut()"},{"location":"api/core/sequences/#kinoml.core.sequences.Biosequence.from_ncbi","text":"Show source code in core/sequences.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @classmethod def from_ncbi ( cls , * accessions : str ,) -> Union [ \"Biosequence\" , Iterable [ \"Biosequence\" ]]: \"\"\" Get FASTA sequence from an online NCBI identifier Parameters: accessions: NCBI identifier. Multiple can be provided! Returns: Retrieved biosequence(s) __Examples__ ```python >>> sequence = AminoAcidSequence.from_ncbi(\"AAC05299.1\") >>> print(sequence[:10]) MSVNSEKSSS >>> print(sequence.name) AAC05299.1 serine kinase SRPK2 [Homo sapiens] ``` \"\"\" if cls . _ACCESSION_URL is None : raise NotImplementedError if len ( accessions ) > cls . ACCESSION_MAX_RETRIEVAL : raise ValueError ( f \"You can only provide { cls . ACCESSION_MAX_RETRIEVAL } accessions at the same time.\" ) r = requests . get ( cls . _ACCESSION_URL . format ( \",\" . join ( accessions ))) r . raise_for_status () sequences = [] for line in r . text . splitlines (): line = line . strip () if not line : continue if line . startswith ( \">\" ): sequences . append ({ \"name\" : line [ 1 :], \"sequence\" : []}) else : sequences [ - 1 ][ \"sequence\" ] . append ( line ) if not sequences : return objects = [] for sequence , accession in zip ( sequences , accessions ): obj = cls ( \"\" . join ( sequence [ \"sequence\" ]), name = sequence [ \"name\" ], _provenance = { \"accession\" : accession }, ) objects . append ( obj ) if not objects : return None if len ( objects ) == 1 : return objects [ 0 ] return objects Get FASTA sequence from an online NCBI identifier Parameters Name Type Description Default *accessions str NCBI identifier. Multiple can be provided! () Returns Type Description Union[ForwardRef('Biosequence'), Iterable[ForwardRef('Biosequence')]] Retrieved biosequence(s) Examples >>> sequence = AminoAcidSequence . from_ncbi ( \"AAC05299.1\" ) >>> print ( sequence [: 10 ]) MSVNSEKSSS >>> print ( sequence . name ) AAC05299 . 1 serine kinase SRPK2 [ Homo sapiens ]","title":"from_ncbi()"},{"location":"api/core/sequences/#kinoml.core.sequences.Biosequence.mutate","text":"Show source code in core/sequences.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def mutate ( self , * mutations : str , raise_errors : bool = True ) -> \"Biosequence\" : \"\"\" Apply a mutation on the sequence using biological notation. Parameters: mutations: Mutations to be applied. Indices are always 1-indexed. It can be one of: (1) substitution, like `C234T` (C at position 234 will be replaced by T); (2) deletion, like `L746-A750del` (delete everything between L at position 746 A at position 750, bounds not included); (3) insertion, like `1151Tins` (insert a T after position 1151) raise_errors: Raise ValueError if one of the mutations is not supported. Returns: The edited sequence Examples: ```python >>> s = Biosequence(\"ATCGTHCTCH\") >>> s.mutate(\"C3P\") \"ATPGTHCTCH\" >>> s.mutate(\"T2-T5del\") \"ATTHCTCH\" >>> s.mutate(\"5Tins\") \"ATCGTTHCTCH\" ``` \"\"\" # We can only handle one insertion or deletion at once now mutation_types = { m : self . _type_mutation ( m , raise_errors ) for m in mutations } mutation_count = Counter ( mutation_types . values ()) if mutation_count [ \"insertion\" ] + mutation_count [ \"deletion\" ] > 1 : msg = f \"Only one simultaneous insertion or deletion is currently supported. You provided ` { ',' . join ( mutations ) } `\" if raise_errors : raise ValueError ( msg ) logger . warning ( \"Warning: %s \" , msg ) return None # Reverse alphabetical order (substitutions will come first) mutated = self for mutation in sorted ( mutations , key = lambda m : mutation_count [ m ], reverse = True ): if None in ( mutation , mutation_types [ mutation ]): continue operation = getattr ( mutated , f \"_mutate_with_ { mutation_types [ mutation ] } \" ) mutated = operation ( mutation ) mutated . name += f \" (mutations: { ', ' . join ( mutations ) } )\" mutated . _provenance . update ({ \"mutations\" : mutations }) return mutated Apply a mutation on the sequence using biological notation. Parameters Name Type Description Default *mutations str Mutations to be applied. Indices are always 1-indexed. It can be one of: (1) substitution, like C234T (C at position 234 will be replaced by T); (2) deletion, like L746-A750del (delete everything between L at position 746 A at position 750, bounds not included); (3) insertion, like 1151Tins (insert a T after position 1151) () raise_errors bool Raise ValueError if one of the mutations is not supported. True Returns Type Description Biosequence The edited sequence Examples: >>> s = Biosequence ( \"ATCGTHCTCH\" ) >>> s . mutate ( \"C3P\" ) \"ATPGTHCTCH\" >>> s . mutate ( \"T2-T5del\" ) \"ATTHCTCH\" >>> s . mutate ( \"5Tins\" ) \"ATCGTTHCTCH\"","title":"mutate()"},{"location":"api/core/sequences/#kinoml.core.sequences.DNASequence","text":"Biosequence that only allows DNA bases","title":"DNASequence"},{"location":"api/core/sequences/#kinoml.core.sequences.RNASequence","text":"Biosequence that only allows RNA bases","title":"RNASequence"},{"location":"api/core/systems/","text":"MeasuredSystem \u00b6 Subclass of System that requires a non-null measurement attribute. ProteinLigandComplex \u00b6 A system with at least one protein and one ligand System \u00b6 System objects host one or more MolecularComponent objects, and, optionally, a measurement. Parameters Name Type Description Default components [<class 'kinoml.core.components.MolecularComponent'>] Molecular entities defining this system required measurement Union[NoneType, kinoml.core.measurements.BaseMeasurement] Optional measurement for this system. None strict bool Whether to perform sanity checks (default) or not. True name : str (property, readonly) \u00b6 Generates a readable name out of the components names weight : float (property, readonly) \u00b6 Calculate the molecular weight of the system Note: This is just an example on how/why this level of abstraction can be useful.","title":"systems"},{"location":"api/core/systems/#kinoml.core.systems.MeasuredSystem","text":"Subclass of System that requires a non-null measurement attribute.","title":"MeasuredSystem"},{"location":"api/core/systems/#kinoml.core.systems.ProteinLigandComplex","text":"A system with at least one protein and one ligand","title":"ProteinLigandComplex"},{"location":"api/core/systems/#kinoml.core.systems.System","text":"System objects host one or more MolecularComponent objects, and, optionally, a measurement. Parameters Name Type Description Default components [<class 'kinoml.core.components.MolecularComponent'>] Molecular entities defining this system required measurement Union[NoneType, kinoml.core.measurements.BaseMeasurement] Optional measurement for this system. None strict bool Whether to perform sanity checks (default) or not. True","title":"System"},{"location":"api/core/systems/#kinoml.core.systems.System.name","text":"Generates a readable name out of the components names","title":"name"},{"location":"api/core/systems/#kinoml.core.systems.System.weight","text":"Calculate the molecular weight of the system Note: This is just an example on how/why this level of abstraction can be useful.","title":"weight"},{"location":"api/datasets/__init__/","text":"::: kinoml.datasets. init","title":"  init  "},{"location":"api/datasets/core/","text":"BaseDatasetProvider \u00b6 Base object for all DatasetProvider classes. Parameters Name Type Description Default systems Iterable[kinoml.core.systems.System] A DatasetProvider holds a list of kinoml.core.systems.System objects (or any of its subclasses). A System is a collection of MolecularComponent objects (e.g. protein or ligand-like entities), plus an optional Measurement . required featurizers Iterable[kinoml.features.core.BaseFeaturizer] Pipeline of descriptor featurization schemes None featurize ( self ) \u00b6 Show source code in datasets/core.py 46 47 48 49 50 def featurize ( self ): \"\"\" Apply featurizers to self.data and self.measurements. \"\"\" raise NotImplementedError Apply featurizers to self.data and self.measurements. from_source ( filename = None , ** kwargs ) (classmethod) \u00b6 Show source code in datasets/core.py 37 38 39 40 41 42 43 44 @classmethod def from_source ( cls , filename = None , ** kwargs ): \"\"\" Parse CSV/raw file to object model. This method is responsible of generating the objects for `self.data` and `self.measurements`, if relevant. Additional kwargs will be passed to `__init__` \"\"\" raise NotImplementedError Parse CSV/raw file to object model. This method is responsible of generating the objects for self.data and self.measurements , if relevant. Additional kwargs will be passed to __init__ to_dataframe ( self , * args , ** kwargs ) \u00b6 Show source code in datasets/core.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def to_dataframe ( self , * args , ** kwargs ): \"\"\" Generates a `pandas.DataFrame` containing information on the systems and their measurements Returns: pandas.DataFrame \"\"\" if not self . systems : return pd . DataFrame () s = self . systems [ 0 ] records = [ [ s . __class__ . __name__ , \"n_components\" , f \"Avg { s . measurement . __class__ . __name__ } \" ,] ] for system in self . systems : records . append ([ system . name , len ( system . components ), system . measurement . values . mean ()]) return pd . DataFrame . from_records ( records [ 1 :], columns = records [ 0 ]) Generates a pandas.DataFrame containing information on the systems and their measurements Returns Type Description _empty pandas.DataFrame","title":"core"},{"location":"api/datasets/core/#kinoml.datasets.core.BaseDatasetProvider","text":"Base object for all DatasetProvider classes. Parameters Name Type Description Default systems Iterable[kinoml.core.systems.System] A DatasetProvider holds a list of kinoml.core.systems.System objects (or any of its subclasses). A System is a collection of MolecularComponent objects (e.g. protein or ligand-like entities), plus an optional Measurement . required featurizers Iterable[kinoml.features.core.BaseFeaturizer] Pipeline of descriptor featurization schemes None","title":"BaseDatasetProvider"},{"location":"api/datasets/core/#kinoml.datasets.core.BaseDatasetProvider.featurize","text":"Show source code in datasets/core.py 46 47 48 49 50 def featurize ( self ): \"\"\" Apply featurizers to self.data and self.measurements. \"\"\" raise NotImplementedError Apply featurizers to self.data and self.measurements.","title":"featurize()"},{"location":"api/datasets/core/#kinoml.datasets.core.BaseDatasetProvider.from_source","text":"Show source code in datasets/core.py 37 38 39 40 41 42 43 44 @classmethod def from_source ( cls , filename = None , ** kwargs ): \"\"\" Parse CSV/raw file to object model. This method is responsible of generating the objects for `self.data` and `self.measurements`, if relevant. Additional kwargs will be passed to `__init__` \"\"\" raise NotImplementedError Parse CSV/raw file to object model. This method is responsible of generating the objects for self.data and self.measurements , if relevant. Additional kwargs will be passed to __init__","title":"from_source()"},{"location":"api/datasets/core/#kinoml.datasets.core.BaseDatasetProvider.to_dataframe","text":"Show source code in datasets/core.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def to_dataframe ( self , * args , ** kwargs ): \"\"\" Generates a `pandas.DataFrame` containing information on the systems and their measurements Returns: pandas.DataFrame \"\"\" if not self . systems : return pd . DataFrame () s = self . systems [ 0 ] records = [ [ s . __class__ . __name__ , \"n_components\" , f \"Avg { s . measurement . __class__ . __name__ } \" ,] ] for system in self . systems : records . append ([ system . name , len ( system . components ), system . measurement . values . mean ()]) return pd . DataFrame . from_records ( records [ 1 :], columns = records [ 0 ]) Generates a pandas.DataFrame containing information on the systems and their measurements Returns Type Description _empty pandas.DataFrame","title":"to_dataframe()"},{"location":"api/datasets/kinomescan/__init__/","text":"::: kinoml.datasets.kinomescan. init","title":"  init  "},{"location":"api/datasets/kinomescan/pkis2/","text":"PKIS2DatasetProvider \u00b6 Loads PKIS2 dataset as provided in Progress towards a public chemogenomic set for protein kinases and a call for contributions 1 . It will build a dataframe where the SMILES-representation of ligands are the index and the columns are the kinase names. To map between KINOMEscan kinase names and actual sequences, helper object kinoml.datatasets.kinomescan.utils.KINOMEScanMapper is instantiated as a class attribute. Examples >>> from kinoml.datasets.kinomescan.pkis2 import PKIS2DatasetProvider >>> provider = PKIS2DatasetProvider . from_source () >>> system = provider . systems [ 0 ] >>> print ( f \"% displacement for kinase= { system . protein . name } and ligand= { system . ligand . to_smiles () } is { system . measurement } \" from_source ( filename = PosixPath ( '/home/runner/work/kinoml/kinoml/kinoml/data/kinomescan/journal.pone.0181585.s004.csv' ), measurement_type =< class ' kinoml . core . measurements . PercentageDisplacementMeasurement '>, conditions=<AssayConditions pH=7.0>, **kwargs) (classmethod) \u00b6 Show source code in kinomescan/pkis2.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @classmethod def from_source ( # pylint: disable=arguments-differ cls , filename : Union [ AnyStr , Path ] = datapath ( \"kinomescan/journal.pone.0181585.s004.csv\" ), measurement_type : BaseMeasurement = PercentageDisplacementMeasurement , conditions : BaseConditions = AssayConditions ( pH = 7.0 ), ** kwargs ): \"\"\" Create a DatasetProvider out of the raw data in a file Parameters: filename: CSV file with the protein-ligand measurements measurement_type: which type of measurement was taken for each pair conditions: experimental conditions of the assay !!! todo Investigate lazy access and object generation \"\"\" df = cls . _read_dataframe ( filename ) # Read in proteins mapper = KINOMEScanMapper () kinases = [] for kin_name in df . columns : sequence = mapper . sequence_for_name ( kin_name ) kinases . append ( AminoAcidSequence ( sequence , name = kin_name )) # Read in ligands ligands = [] for smiles in df . index [ df . index . notna ()]: ligand = Ligand . from_smiles ( smiles , allow_undefined_stereo = True ) ligands . append ( ligand ) # Build ProteinLigandComplex objects complexes = [] for i , ligand in enumerate ( ligands ): for j , kinase in enumerate ( kinases ): measurement = measurement_type ( df . iloc [ i , j ], conditions = conditions , components = [ kinase , ligand ] ) comp = ProteinLigandComplex ( components = [ kinase , ligand ], measurement = measurement ) complexes . append ( comp ) return cls ( systems = complexes , conditions = conditions , ** kwargs ) Create a DatasetProvider out of the raw data in a file Parameters Name Type Description Default filename Union[~AnyStr, pathlib.Path] CSV file with the protein-ligand measurements PosixPath('/home/runner/work/kinoml/kinoml/kinoml/data/kinomescan/journal.pone.0181585.s004.csv') measurement_type BaseMeasurement which type of measurement was taken for each pair <class 'kinoml.core.measurements.PercentageDisplacementMeasurement'> conditions BaseConditions experimental conditions of the assay <AssayConditions pH=7.0> Todo Investigate lazy access and object generation DOI: 10.1371/journal.pone.0181585 \u21a9","title":"pkis2"},{"location":"api/datasets/kinomescan/pkis2/#kinoml.datasets.kinomescan.pkis2.PKIS2DatasetProvider","text":"Loads PKIS2 dataset as provided in Progress towards a public chemogenomic set for protein kinases and a call for contributions 1 . It will build a dataframe where the SMILES-representation of ligands are the index and the columns are the kinase names. To map between KINOMEscan kinase names and actual sequences, helper object kinoml.datatasets.kinomescan.utils.KINOMEScanMapper is instantiated as a class attribute. Examples >>> from kinoml.datasets.kinomescan.pkis2 import PKIS2DatasetProvider >>> provider = PKIS2DatasetProvider . from_source () >>> system = provider . systems [ 0 ] >>> print ( f \"% displacement for kinase= { system . protein . name } and ligand= { system . ligand . to_smiles () } is { system . measurement } \"","title":"PKIS2DatasetProvider"},{"location":"api/datasets/kinomescan/pkis2/#kinoml.datasets.kinomescan.pkis2.PKIS2DatasetProvider.from_source","text":"Show source code in kinomescan/pkis2.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @classmethod def from_source ( # pylint: disable=arguments-differ cls , filename : Union [ AnyStr , Path ] = datapath ( \"kinomescan/journal.pone.0181585.s004.csv\" ), measurement_type : BaseMeasurement = PercentageDisplacementMeasurement , conditions : BaseConditions = AssayConditions ( pH = 7.0 ), ** kwargs ): \"\"\" Create a DatasetProvider out of the raw data in a file Parameters: filename: CSV file with the protein-ligand measurements measurement_type: which type of measurement was taken for each pair conditions: experimental conditions of the assay !!! todo Investigate lazy access and object generation \"\"\" df = cls . _read_dataframe ( filename ) # Read in proteins mapper = KINOMEScanMapper () kinases = [] for kin_name in df . columns : sequence = mapper . sequence_for_name ( kin_name ) kinases . append ( AminoAcidSequence ( sequence , name = kin_name )) # Read in ligands ligands = [] for smiles in df . index [ df . index . notna ()]: ligand = Ligand . from_smiles ( smiles , allow_undefined_stereo = True ) ligands . append ( ligand ) # Build ProteinLigandComplex objects complexes = [] for i , ligand in enumerate ( ligands ): for j , kinase in enumerate ( kinases ): measurement = measurement_type ( df . iloc [ i , j ], conditions = conditions , components = [ kinase , ligand ] ) comp = ProteinLigandComplex ( components = [ kinase , ligand ], measurement = measurement ) complexes . append ( comp ) return cls ( systems = complexes , conditions = conditions , ** kwargs ) Create a DatasetProvider out of the raw data in a file Parameters Name Type Description Default filename Union[~AnyStr, pathlib.Path] CSV file with the protein-ligand measurements PosixPath('/home/runner/work/kinoml/kinoml/kinoml/data/kinomescan/journal.pone.0181585.s004.csv') measurement_type BaseMeasurement which type of measurement was taken for each pair <class 'kinoml.core.measurements.PercentageDisplacementMeasurement'> conditions BaseConditions experimental conditions of the assay <AssayConditions pH=7.0> Todo Investigate lazy access and object generation DOI: 10.1371/journal.pone.0181585 \u21a9","title":"from_source()"},{"location":"api/datasets/kinomescan/utils/","text":"KINOMEScanMapper \u00b6 This helper class helps retrieve sequence information out of the raw data provided by DiscoverX, which only offers NCBI accessions, mutations and construct limits. We process this to obtain a FASTA sequence that can be ingested in our pipelines. Since this relies on online queries, it will cache the results to disk by default. Parameters Name Type Description Default raw_datasheet Union[~AnyStr, pathlib.Path] Raw CSV file with the DiscoverX information PosixPath('/home/runner/work/kinoml/kinoml/kinoml/data/kinomescan/DiscoverX_489_Kinase_Assay_Construct_Information.csv') use_cache bool Whether to read the data from cache if possible. Set to False to ignore existing caches and rewrite them. True sequence_for_accession ( self , accession ) \u00b6 Show source code in kinomescan/utils.py 66 67 68 69 70 def sequence_for_accession ( self , accession : AnyStr ): \"\"\" Given a NCBI identifier, return the corresponding FASTA sequence \"\"\" return self . _data [ self . _data . accession == accession ] . sequence . values Given a NCBI identifier, return the corresponding FASTA sequence sequence_for_name ( self , name ) \u00b6 Show source code in kinomescan/utils.py 60 61 62 63 64 def sequence_for_name ( self , name : AnyStr ): \"\"\" Given a kinase name, return the corresponding FASTA sequence \"\"\" return self . _data . loc [ name , \"sequence\" ] Given a kinase name, return the corresponding FASTA sequence","title":"utils"},{"location":"api/datasets/kinomescan/utils/#kinoml.datasets.kinomescan.utils.KINOMEScanMapper","text":"This helper class helps retrieve sequence information out of the raw data provided by DiscoverX, which only offers NCBI accessions, mutations and construct limits. We process this to obtain a FASTA sequence that can be ingested in our pipelines. Since this relies on online queries, it will cache the results to disk by default. Parameters Name Type Description Default raw_datasheet Union[~AnyStr, pathlib.Path] Raw CSV file with the DiscoverX information PosixPath('/home/runner/work/kinoml/kinoml/kinoml/data/kinomescan/DiscoverX_489_Kinase_Assay_Construct_Information.csv') use_cache bool Whether to read the data from cache if possible. Set to False to ignore existing caches and rewrite them. True","title":"KINOMEScanMapper"},{"location":"api/datasets/kinomescan/utils/#kinoml.datasets.kinomescan.utils.KINOMEScanMapper.sequence_for_accession","text":"Show source code in kinomescan/utils.py 66 67 68 69 70 def sequence_for_accession ( self , accession : AnyStr ): \"\"\" Given a NCBI identifier, return the corresponding FASTA sequence \"\"\" return self . _data [ self . _data . accession == accession ] . sequence . values Given a NCBI identifier, return the corresponding FASTA sequence","title":"sequence_for_accession()"},{"location":"api/datasets/kinomescan/utils/#kinoml.datasets.kinomescan.utils.KINOMEScanMapper.sequence_for_name","text":"Show source code in kinomescan/utils.py 60 61 62 63 64 def sequence_for_name ( self , name : AnyStr ): \"\"\" Given a kinase name, return the corresponding FASTA sequence \"\"\" return self . _data . loc [ name , \"sequence\" ] Given a kinase name, return the corresponding FASTA sequence","title":"sequence_for_name()"},{"location":"api/docking/__init__/","text":"","title":"docking"},{"location":"api/features/__init__/","text":"Featurizers will always output arrays but they will use structure-oriented methods underneath to do it.","title":"features"},{"location":"api/ml/__init__/","text":"","title":"ml"},{"location":"api/modeling/__init__/","text":"","title":"modeling"},{"location":"api/optimize/__init__/","text":"","title":"optimize"},{"location":"api/tests/__init__/","text":"::: kinoml.tests. init","title":"  init  "},{"location":"api/tests/test_core_protein/","text":"::: kinoml.tests.test_core_protein","title":"Test core protein"},{"location":"api/tests/test_kinoml/","text":"::: kinoml.tests.test_kinoml","title":"Test kinoml"},{"location":"api/workflows/__init__/","text":"","title":"workflows"},{"location":"developers/api_concepts/","text":"Base concepts in our API \u00b6 DatasetProvider \u00b6 This object is responsible for: Taking raw data as provided by source/calculation/experiment Featurizing the input chemical information to obtain numerical values Transforming (featurizing) the known measurements to compatible magnitudes Generating downstream Dataset-like objects natively compatible with the expected framework (tensorflow, pytorch, scikit-learn, etc). The process of going from chemical-like information to numerical information is called featurization , and is performed by featurizers . Most featurizers will work in a one-by-one basis: they only need one input to provide the output. Some, however, could need contextual information from the dataset to perform that operation (averaging measurements, caching already existing structures, etc). As a result, they all can take an additional optional keyword argument holding the whole dataset. def featurizer ( data_point_to_featurize , dataset = None ): pass Chemical data -------[featurization]----> Numerical n-dimensional arrays ---> Framework-native object In this step, we might also perform filtering: discard non-desired/compatible data points. This is done with Filter objects. Filtering alters the shape of the data because it will always remove data points following some criterion. Dataset \u00b6 This object contains numerical data only. They can be post-processed with Transformer objects native to the framework in use. MolecularSystem \u00b6 This object is central to DatasetProvider, because it describes the object model that will hold all the chemical information we can infer from the raw data. For example: Smiles -> Ligand(MolecularSystem) Protein Sequences -> Protein(MolecularSystem) PDB -> Complex(MolecularSystem) They need to provide most of the information featurizers will expect. To this effect, MolecularSystem will provide flags that report what type of info is available for featurizers to check for compatibility.","title":"Base concepts"},{"location":"developers/api_concepts/#base-concepts-in-our-api","text":"","title":"Base concepts in our API"},{"location":"developers/api_concepts/#datasetprovider","text":"This object is responsible for: Taking raw data as provided by source/calculation/experiment Featurizing the input chemical information to obtain numerical values Transforming (featurizing) the known measurements to compatible magnitudes Generating downstream Dataset-like objects natively compatible with the expected framework (tensorflow, pytorch, scikit-learn, etc). The process of going from chemical-like information to numerical information is called featurization , and is performed by featurizers . Most featurizers will work in a one-by-one basis: they only need one input to provide the output. Some, however, could need contextual information from the dataset to perform that operation (averaging measurements, caching already existing structures, etc). As a result, they all can take an additional optional keyword argument holding the whole dataset. def featurizer ( data_point_to_featurize , dataset = None ): pass Chemical data -------[featurization]----> Numerical n-dimensional arrays ---> Framework-native object In this step, we might also perform filtering: discard non-desired/compatible data points. This is done with Filter objects. Filtering alters the shape of the data because it will always remove data points following some criterion.","title":"DatasetProvider"},{"location":"developers/api_concepts/#dataset","text":"This object contains numerical data only. They can be post-processed with Transformer objects native to the framework in use.","title":"Dataset"},{"location":"developers/api_concepts/#molecularsystem","text":"This object is central to DatasetProvider, because it describes the object model that will hold all the chemical information we can infer from the raw data. For example: Smiles -> Ligand(MolecularSystem) Protein Sequences -> Protein(MolecularSystem) PDB -> Complex(MolecularSystem) They need to provide most of the information featurizers will expect. To this effect, MolecularSystem will provide flags that report what type of info is available for featurizers to check for compatibility.","title":"MolecularSystem"},{"location":"developers/api_docs/","text":"How to write docs with mkdocs \u00b6 For full documentation visit mkdocs.org . Basics \u00b6 mkdocs serve - Start the live-reloading docs server locally Project layout: mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. MkDocs are markdown documents, so the answer is easy: just use plain Markdown and, optionally, the supported extensions. More info in the official docs . Supported extensions \u00b6 The theme we are using is material , which supports very fancy extensions . Admonitions \u00b6 Tip This is so cool huh? Check all styles here . !!! tip This is so cool huh? Check all styles [ here ]( https://squidfunk.github.io/mkdocs-material/extensions/admonition/#types ). Citations \u00b6 This is a very important finding. 1 This is yet another finding. 2 These are written with labels like this: > This is a very important finding.[^1] > This is yet another finding.[^Rodr\u00edguez-Guerra and Pedregal, 1990] [ ^1 ]: Lorem ipsum dolor sit amet, consectetur adipiscing elit. [ ^Rodr\u00edguez-Guerra and Pedregal, 1990 ]: A kid named Jaime. LaTeX \u00b6 Either in blocks \\frac{n!}{k!(n-k)!} = \\binom{n}{k} * Jaime \\frac{n!}{k!(n-k)!} = \\binom{n}{k} * Jaime $$ \\frac {n ! }{k !( n - k )! } = \\binom {n}{k} * Jaime $$ or inline: This my best equation ever: p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} This my best equation ever: $ p ( x|y ) = \\frac {p ( y|x ) p ( x ) }{p ( y ) } $ Checkboxes \u00b6 Checkbox Checkbox - [ ] Checkbox - [X] Checkbox Emoji \u00b6 Github shortcuts are supported: :smile: :heart: :thumbsup: Tabbed fences \u00b6 Step 1 This is the step 1 Step 2 # This is the step 2 with python code highlighting he = Element ( \"Helium\" ) Step 3 This is the step 3 This line interrupts the fences and creates a new block of tabs Step 4 # This is the step 4 with python code highlighting be = Element ( \"Beryllium\" ) Obtained with: ``` tab=\"Step 1\" This is the step 1 ``` ```python tab=\"Step 2\" # This is the step 2 with python code highlighting he = Element(\"Helium\") ``` ``` tab=\"Step 3\" This is the step 3 ``` This line interrupts the fences and creates a new block of tabs ```python tab=\"Step 4\" # This is the step 4 with python code highlighting be = Element(\"Beryllium\") ``` Extra inline markup \u00b6 Code Result ==hey== hey ~~hey~~ hey ^^hey^^ hey a^migo^ a migo --> \u2192 Docstrings \u00b6 We are using mkdocstrings for our docstrings, which deviate slightly from the more popular numpydoc syntax. Instead, it's closer to Google-style docstrings . To sum up, this is a more or less complete example of the requested syntax: \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Note: We omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. __Examples__ Experimental support. You need code fences and an extra blank line at the end so they can be highlighted _and_ recognized by `pytest`. Check https://github.com/pawamoy/mkdocstrings/issues/52 for updates. ```python >>> 2 + 2 == 4 True ``` \"\"\" Real docstring examples \u00b6 Check docs.developers._docstrings_example and its source code below. Example module to show how docstrings are written for mkdocs + mkdocstrings example_function ( arg1 , kwarg = None ) \u00b6 Show source code in developers/_docstrings_example.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def example_function ( arg1 , kwarg = None ) -> object : \"\"\" Example function to demonstrate how APIs are rendered Parameters: arg1 (dict): Some description for this argument. This type (in parenthesis) is ignored. kwarg: Some more descriptions Returns: A description for the returned value __Examples__ This can be automatically tested with `pytest --doctest-modules`! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 ```python >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest ``` \"\"\" pass Example function to demonstrate how APIs are rendered Parameters Name Type Description Default arg1 _empty Some description for this argument. This type (in parenthesis) is ignored. required kwarg _empty Some more descriptions None Returns Type Description object A description for the returned value Examples This can be automatically tested with pytest --doctest-modules ! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest example_function_with_type_hints ( arg1 , kwarg = None ) \u00b6 Show source code in developers/_docstrings_example.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def example_function_with_type_hints ( arg1 : dict , kwarg : typing . Any = None ) -> object : \"\"\" Example function to demonstrate how APIs are rendered Parameters: arg1: Some description for this argument. kwarg: Some more descriptions Returns: A description for the returned value __Examples__ This can be automatically tested with `pytest --doctest-modules`! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 ```python >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest ``` \"\"\" pass Example function to demonstrate how APIs are rendered Parameters Name Type Description Default arg1 dict Some description for this argument. required kwarg Any Some more descriptions None Returns Type Description object A description for the returned value Examples This can be automatically tested with pytest --doctest-modules ! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 A kid named Jaime. \u21a9","title":"How to write docs"},{"location":"developers/api_docs/#how-to-write-docs-with-mkdocs","text":"For full documentation visit mkdocs.org .","title":"How to write docs with mkdocs"},{"location":"developers/api_docs/#basics","text":"mkdocs serve - Start the live-reloading docs server locally Project layout: mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. MkDocs are markdown documents, so the answer is easy: just use plain Markdown and, optionally, the supported extensions. More info in the official docs .","title":"Basics"},{"location":"developers/api_docs/#supported-extensions","text":"The theme we are using is material , which supports very fancy extensions .","title":"Supported extensions"},{"location":"developers/api_docs/#admonitions","text":"Tip This is so cool huh? Check all styles here . !!! tip This is so cool huh? Check all styles [ here ]( https://squidfunk.github.io/mkdocs-material/extensions/admonition/#types ).","title":"Admonitions"},{"location":"developers/api_docs/#citations","text":"This is a very important finding. 1 This is yet another finding. 2 These are written with labels like this: > This is a very important finding.[^1] > This is yet another finding.[^Rodr\u00edguez-Guerra and Pedregal, 1990] [ ^1 ]: Lorem ipsum dolor sit amet, consectetur adipiscing elit. [ ^Rodr\u00edguez-Guerra and Pedregal, 1990 ]: A kid named Jaime.","title":"Citations"},{"location":"developers/api_docs/#latex","text":"Either in blocks \\frac{n!}{k!(n-k)!} = \\binom{n}{k} * Jaime \\frac{n!}{k!(n-k)!} = \\binom{n}{k} * Jaime $$ \\frac {n ! }{k !( n - k )! } = \\binom {n}{k} * Jaime $$ or inline: This my best equation ever: p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} This my best equation ever: $ p ( x|y ) = \\frac {p ( y|x ) p ( x ) }{p ( y ) } $","title":"LaTeX"},{"location":"developers/api_docs/#checkboxes","text":"Checkbox Checkbox - [ ] Checkbox - [X] Checkbox","title":"Checkboxes"},{"location":"developers/api_docs/#emoji","text":"Github shortcuts are supported: :smile: :heart: :thumbsup:","title":"Emoji"},{"location":"developers/api_docs/#tabbed-fences","text":"Step 1 This is the step 1 Step 2 # This is the step 2 with python code highlighting he = Element ( \"Helium\" ) Step 3 This is the step 3 This line interrupts the fences and creates a new block of tabs Step 4 # This is the step 4 with python code highlighting be = Element ( \"Beryllium\" ) Obtained with: ``` tab=\"Step 1\" This is the step 1 ``` ```python tab=\"Step 2\" # This is the step 2 with python code highlighting he = Element(\"Helium\") ``` ``` tab=\"Step 3\" This is the step 3 ``` This line interrupts the fences and creates a new block of tabs ```python tab=\"Step 4\" # This is the step 4 with python code highlighting be = Element(\"Beryllium\") ```","title":"Tabbed fences"},{"location":"developers/api_docs/#extra-inline-markup","text":"Code Result ==hey== hey ~~hey~~ hey ^^hey^^ hey a^migo^ a migo --> \u2192","title":"Extra inline markup"},{"location":"developers/api_docs/#docstrings","text":"We are using mkdocstrings for our docstrings, which deviate slightly from the more popular numpydoc syntax. Instead, it's closer to Google-style docstrings . To sum up, this is a more or less complete example of the requested syntax: \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Note: We omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. __Examples__ Experimental support. You need code fences and an extra blank line at the end so they can be highlighted _and_ recognized by `pytest`. Check https://github.com/pawamoy/mkdocstrings/issues/52 for updates. ```python >>> 2 + 2 == 4 True ``` \"\"\"","title":"Docstrings"},{"location":"developers/api_docs/#real-docstring-examples","text":"Check docs.developers._docstrings_example and its source code below. Example module to show how docstrings are written for mkdocs + mkdocstrings","title":"Real docstring examples"},{"location":"developers/api_docs/#docs.developers._docstrings_example.example_function","text":"Show source code in developers/_docstrings_example.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def example_function ( arg1 , kwarg = None ) -> object : \"\"\" Example function to demonstrate how APIs are rendered Parameters: arg1 (dict): Some description for this argument. This type (in parenthesis) is ignored. kwarg: Some more descriptions Returns: A description for the returned value __Examples__ This can be automatically tested with `pytest --doctest-modules`! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 ```python >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest ``` \"\"\" pass Example function to demonstrate how APIs are rendered Parameters Name Type Description Default arg1 _empty Some description for this argument. This type (in parenthesis) is ignored. required kwarg _empty Some more descriptions None Returns Type Description object A description for the returned value Examples This can be automatically tested with pytest --doctest-modules ! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest","title":"example_function()"},{"location":"developers/api_docs/#docs.developers._docstrings_example.example_function_with_type_hints","text":"Show source code in developers/_docstrings_example.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def example_function_with_type_hints ( arg1 : dict , kwarg : typing . Any = None ) -> object : \"\"\" Example function to demonstrate how APIs are rendered Parameters: arg1: Some description for this argument. kwarg: Some more descriptions Returns: A description for the returned value __Examples__ This can be automatically tested with `pytest --doctest-modules`! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 ```python >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest ``` \"\"\" pass Example function to demonstrate how APIs are rendered Parameters Name Type Description Default arg1 dict Some description for this argument. required kwarg Any Some more descriptions None Returns Type Description object A description for the returned value Examples This can be automatically tested with pytest --doctest-modules ! Syntax might change subtly in the future. Check https://github.com/pawamoy/mkdocstrings/issues/52 >>> 2 + 2 == 4 True # this passes pytest >>> 2 + 2 == 5 True # this fails pytest Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 A kid named Jaime. \u21a9","title":"example_function_with_type_hints()"},{"location":"tutorials/example/","text":"Tutorial 1 \u00b6 Just an example. This could be a Jupyter Notebook if we use the adequate extensions.","title":"Example 1"},{"location":"tutorials/example/#tutorial-1","text":"Just an example. This could be a Jupyter Notebook if we use the adequate extensions.","title":"Tutorial 1"}]}